# 团餐菜单生成工具 - 性能优化指南

## 📖 概述

本文档为系统性能优化提供全面的指导，包括前端优化、后端优化、数据库优化、监控指标等。通过系统化的优化措施，确保应用在各种负载下都能保持良好的用户体验。

---

## 🎯 性能目标

### 核心指标

| 指标名称 | 目标值 | 当前状态 | 优化优先级 |
|---------|--------|----------|------------|
| 首页加载时间 | < 1.5s | ~2.0s | 高 |
| 菜单生成响应 | < 30s | ~45s | 高 |
| API响应时间 | < 500ms | ~800ms | 中 |
| 数据库查询 | < 100ms | ~150ms | 中 |
| Excel导出 | < 2s | ~3s | 低 |

### 用户体验目标

- **可用性**：99.9% 正常运行时间
- **并发性**：支持100+并发用户
- **响应性**：3秒内完成所有交互
- **稳定性**：内存使用 < 512MB

---

## 🚀 前端性能优化

### 代码分割和懒加载

#### Next.js动态导入
```typescript
// 组件懒加载
import dynamic from 'next/dynamic'

// 延迟加载重的组件
const MenuTable = dynamic(() => import('./MenuTable'), {
  loading: () => <Spin size="large" />,
  ssr: false  // 如果组件不需要服务端渲染
})

// 页面级别的代码分割
const HistoryPage = dynamic(() => import('../history/page'), {
  loading: () => <div>加载中...</div>
})
```

#### 按需加载库
```typescript
// Ant Design按需导入
import { Button, Form, Table } from 'antd'
// 而不是 import * as antd from 'antd'

// Excel库按需加载
const exportToExcel = async () => {
  const XLSX = await import('xlsx')
  // 使用XLSX进行导出
}

// 动态导入工具库
const formatDate = async (date: Date) => {
  const { format } = await import('date-fns')
  return format(date, 'yyyy-MM-dd')
}
```

### 资源优化

#### 图片优化
```typescript
// 使用Next.js Image组件
import Image from 'next/image'

// 自动优化、懒加载、WebP格式
<Image
  src="/logo.png"
  alt="Logo"
  width={200}
  height={100}
  priority  // 首屏图片设置优先级
  placeholder="blur"  // 模糊占位符
/>
```

#### 字体优化
```typescript
// 在layout.tsx中使用Next.js字体优化
import { Inter } from 'next/font/google'

const inter = Inter({
  subsets: ['latin'],
  display: 'swap',  // 字体交换策略
  preload: true     // 预加载
})

export default function Layout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="zh-CN" className={inter.className}>
      <body>{children}</body>
    </html>
  )
}
```

### 状态管理优化

#### React性能优化
```typescript
// 1. 使用useMemo缓存计算结果
const getDefaultValues = useMemo(() => {
  if (!canteenInfo) return {}
  
  const hotCount = canteenInfo.hotDishCount
  const avgCount = Math.ceil(hotCount / 3)
  
  return {
    mainMeatCount: avgCount,
    halfMeatCount: avgCount,
    vegetarianCount: hotCount - (avgCount * 2),
    // ... 其他默认值
  }
}, [canteenInfo])

// 2. 使用useCallback优化函数引用
const handleFormSubmit = useCallback(async (values: FormData) => {
  setGenerating(true)
  try {
    await generateMenu(values)
  } finally {
    setGenerating(false)
  }
}, [generateMenu])

// 3. 组件memo优化
const MenuTable = memo(({ weekMenu, hotDishCount, coldDishCount }: MenuTableProps) => {
  // 组件实现
}, (prevProps, nextProps) => {
  // 自定义比较逻辑
  return prevProps.weekMenu === nextProps.weekMenu
})
```

#### 数据缓存策略
```typescript
// 使用SWR进行数据缓存
import useSWR from 'swr'

const fetcher = (url: string) => fetch(url).then(res => res.json())

export function useCanteenInfo() {
  const { data, error, mutate } = useSWR('/api/auth/me', fetcher, {
    revalidateOnFocus: false,
    revalidateOnReconnect: true,
    dedupingInterval: 60000,  // 1分钟内去重
  })
  
  return {
    canteenInfo: data?.canteen,
    isLoading: !error && !data,
    isError: error,
    refresh: mutate
  }
}

// 使用缓存
const { canteenInfo, isLoading } = useCanteenInfo()
```

---

## ⚡ 后端性能优化

### API响应优化

#### 响应时间优化
```typescript
// 1. 接口缓存
import { LRUCache } from 'lru-cache'

const cache = new LRUCache<string, any>({
  max: 100,
  ttl: 1000 * 60 * 5  // 5分钟缓存
})

export async function GET(request: NextRequest) {
  const cacheKey = `canteen:${canteenId}`
  
  // 检查缓存
  let canteenInfo = cache.get(cacheKey)
  if (!canteenInfo) {
    canteenInfo = await prisma.canteen.findUnique({
      where: { id: canteenId },
      select: {
        id: true,
        canteenName: true,
        hotDishCount: true,
        coldDishCount: true,
        mealType: true,
        // 不返回大字段
        // historicalMenus: true,
      }
    })
    cache.set(cacheKey, canteenInfo)
  }
  
  return NextResponse.json({ canteen: canteenInfo })
}
```

#### 数据库查询优化
```typescript
// 1. 使用select减少数据传输
const canteen = await prisma.canteen.findUnique({
  where: { id: canteenId },
  select: {
    id: true,
    canteenName: true,
    hotDishCount: true,
    coldDishCount: true,
    // 不查询大的JSON字段，除非必要
    // historicalMenus: true,
  }
})

// 2. 批量查询优化
const menusWithCanteen = await prisma.menu.findMany({
  where: { canteenId },
  include: {
    canteen: {
      select: {
        canteenName: true
      }
    }
  },
  orderBy: { createdAt: 'desc' },
  take: 4  // 限制返回数量
})

// 3. 使用原生查询优化复杂场景
const result = await prisma.$queryRaw`
  SELECT m.*, c.canteenName 
  FROM menus m 
  JOIN canteens c ON m.canteenId = c.id 
  WHERE m.canteenId = ${canteenId} 
  ORDER BY m.createdAt DESC 
  LIMIT 4
`
```

### AI API优化

#### 请求优化
```typescript
// 1. 连接池管理
const aiClient = new HTTPClient({
  timeout: 30000,
  keepAlive: true,
  maxSockets: 10
})

// 2. 重试机制优化
async function callDeepseekAPIWithRetry(prompt: string, maxRetries = 3): Promise<string> {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const controller = new AbortController()
      const timeoutId = setTimeout(() => controller.abort(), 25000)  // 25秒超时
      
      const response = await fetch('https://api.deepseek.com/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${process.env.DEEPSEEK_API_KEY}`,
        },
        body: JSON.stringify({
          model: 'deepseek-chat',
          messages: [{ role: 'user', content: prompt }],
          temperature: 0.7,
          max_tokens: 3000,  // 适当限制token数量
        }),
        signal: controller.signal
      })
      
      clearTimeout(timeoutId)
      
      if (!response.ok) {
        throw new Error(`API Error: ${response.status}`)
      }
      
      const data = await response.json()
      return data.choices[0]?.message?.content
      
    } catch (error) {
      console.warn(`Attempt ${attempt} failed:`, error.message)
      
      if (attempt === maxRetries) {
        throw error
      }
      
      // 指数退避
      const delay = Math.pow(2, attempt - 1) * 1000
      await new Promise(resolve => setTimeout(resolve, delay))
    }
  }
}

// 3. Prompt优化
function optimizePrompt(originalPrompt: string): string {
  // 移除不必要的重复内容
  // 压缩历史菜单数据
  // 简化输出要求
  return originalPrompt
    .replace(/\n\n+/g, '\n')  // 移除多余换行
    .trim()
}
```

---

## 🗄 数据库性能优化

### 索引优化

#### 分析查询性能
```sql
-- 1. 启用查询统计
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;

-- 2. 查看慢查询
SELECT 
  query,
  calls,
  total_time,
  mean_time,
  rows
FROM pg_stat_statements 
WHERE mean_time > 100  -- 超过100ms的查询
ORDER BY mean_time DESC
LIMIT 10;

-- 3. 分析查询计划
EXPLAIN ANALYZE SELECT * FROM menus 
WHERE canteenId = 'clxxxxx' 
ORDER BY createdAt DESC 
LIMIT 4;
```

#### 优化索引设计
```sql
-- 1. 复合索引优化菜单查询
CREATE INDEX CONCURRENTLY idx_menus_canteen_created 
ON menus(canteenId, createdAt DESC);

-- 2. 部分索引优化特定查询
CREATE INDEX CONCURRENTLY idx_menus_recent 
ON menus(canteenId, createdAt) 
WHERE createdAt > NOW() - INTERVAL '30 days';

-- 3. 表达式索引
CREATE INDEX CONCURRENTLY idx_canteens_name_lower 
ON canteens(LOWER(canteenName));
```

### 连接池优化

#### Prisma连接配置
```typescript
// prisma/schema.prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// 连接池优化
const prisma = new PrismaClient({
  datasources: {
    db: {
      url: process.env.DATABASE_URL + '?connection_limit=10&pool_timeout=20&socket_timeout=30'
    }
  },
  log: process.env.NODE_ENV === 'development' ? ['query', 'info', 'warn'] : ['warn']
})

// 连接生命周期管理
if (process.env.NODE_ENV === 'production') {
  // 生产环境定期检查连接状态
  setInterval(async () => {
    try {
      await prisma.$queryRaw`SELECT 1`
    } catch (error) {
      console.error('Database health check failed:', error)
    }
  }, 30000)
}
```

### 数据清理策略

#### 自动清理过期数据
```typescript
// 定期清理任务
async function cleanupOldData() {
  try {
    // 1. 清理超过90天的菜单记录
    const oldMenusCount = await prisma.menu.deleteMany({
      where: {
        createdAt: {
          lt: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000)
        }
      }
    })
    
    console.log(`清理了 ${oldMenusCount.count} 条过期菜单记录`)
    
    // 2. 保持每个食堂最多4条记录
    const canteens = await prisma.canteen.findMany({
      select: { id: true }
    })
    
    for (const canteen of canteens) {
      const allMenus = await prisma.menu.findMany({
        where: { canteenId: canteen.id },
        orderBy: { createdAt: 'desc' },
        select: { id: true }
      })
      
      if (allMenus.length > 4) {
        await prisma.menu.deleteMany({
          where: {
            id: {
              in: allMenus.slice(4).map(m => m.id)
            }
          }
        })
      }
    }
  } catch (error) {
    console.error('数据清理失败:', error)
  }
}

// 每天凌晨3点执行清理
if (process.env.NODE_ENV === 'production') {
  setInterval(cleanupOldData, 24 * 60 * 60 * 1000)
}
```

---

## 📊 监控和指标

### 性能监控体系

#### 关键性能指标(KPI)
```typescript
interface PerformanceMetrics {
  // 响应时间指标
  avgResponseTime: number
  p50ResponseTime: number
  p95ResponseTime: number
  p99ResponseTime: number
  
  // 吞吐量指标
  requestsPerSecond: number
  requestsPerMinute: number
  
  // 错误率指标
  errorRate: number
  timeoutRate: number
  
  // 资源使用指标
  memoryUsage: number
  cpuUsage: number
  databaseConnections: number
}

// 性能监控中间件
function performanceMiddleware(req: NextRequest) {
  const startTime = Date.now()
  
  return {
    onFinish: (response: NextResponse) => {
      const duration = Date.now() - startTime
      
      // 记录性能指标
      console.log(`${req.method} ${req.url} - ${duration}ms - ${response.status}`)
      
      // 发送到监控系统
      sendMetrics({
        method: req.method,
        url: req.url,
        duration,
        status: response.status,
        timestamp: new Date().toISOString()
      })
    }
  }
}
```

#### 自定义监控仪表板
```typescript
// 实时性能数据收集
class PerformanceCollector {
  private metrics: Map<string, number[]> = new Map()
  
  recordMetric(name: string, value: number) {
    if (!this.metrics.has(name)) {
      this.metrics.set(name, [])
    }
    
    const values = this.metrics.get(name)!
    values.push(value)
    
    // 保持最近1000个数据点
    if (values.length > 1000) {
      values.shift()
    }
  }
  
  getStats(name: string) {
    const values = this.metrics.get(name) || []
    if (values.length === 0) return null
    
    const sorted = [...values].sort((a, b) => a - b)
    return {
      count: values.length,
      avg: values.reduce((a, b) => a + b, 0) / values.length,
      min: sorted[0],
      max: sorted[sorted.length - 1],
      p50: sorted[Math.floor(sorted.length * 0.5)],
      p95: sorted[Math.floor(sorted.length * 0.95)],
      p99: sorted[Math.floor(sorted.length * 0.99)]
    }
  }
  
  exportMetrics() {
    const report: Record<string, any> = {}
    for (const [name, _] of this.metrics) {
      report[name] = this.getStats(name)
    }
    return report
  }
}

// 全局性能收集器
const perfCollector = new PerformanceCollector()

// API路由中使用
export async function POST(request: NextRequest) {
  const startTime = Date.now()
  
  try {
    // 业务逻辑
    const result = await processRequest(request)
    
    perfCollector.recordMetric('api.success.duration', Date.now() - startTime)
    return result
    
  } catch (error) {
    perfCollector.recordMetric('api.error.duration', Date.now() - startTime)
    perfCollector.recordMetric('api.error.count', 1)
    throw error
  }
}
```

### 告警系统

#### 阈值监控
```typescript
interface AlertThreshold {
  metricName: string
  threshold: number
  operator: 'gt' | 'lt' | 'eq'
  window: number  // 时间窗口（秒）
  severity: 'low' | 'medium' | 'high' | 'critical'
}

const alertRules: AlertThreshold[] = [
  {
    metricName: 'api.response.p95',
    threshold: 5000,  // 5秒
    operator: 'gt',
    window: 300,      // 5分钟
    severity: 'high'
  },
  {
    metricName: 'api.error.rate',
    threshold: 0.05,  // 5%
    operator: 'gt',
    window: 60,       // 1分钟
    severity: 'critical'
  },
  {
    metricName: 'database.connections',
    threshold: 8,     // 80%的连接池
    operator: 'gt',
    window: 60,
    severity: 'medium'
  }
]

class AlertManager {
  private alerts: Map<string, Date> = new Map()
  
  checkAlerts(metrics: PerformanceMetrics) {
    for (const rule of alertRules) {
      const value = this.getMetricValue(metrics, rule.metricName)
      const shouldAlert = this.evaluateCondition(value, rule)
      
      if (shouldAlert && !this.isAlertCooldown(rule.metricName)) {
        this.sendAlert(rule, value)
        this.alerts.set(rule.metricName, new Date())
      }
    }
  }
  
  private isAlertCooldown(metricName: string): boolean {
    const lastAlert = this.alerts.get(metricName)
    if (!lastAlert) return false
    
    const cooldownPeriod = 15 * 60 * 1000  // 15分钟冷却期
    return Date.now() - lastAlert.getTime() < cooldownPeriod
  }
  
  private async sendAlert(rule: AlertThreshold, value: number) {
    const alertMessage = {
      metric: rule.metricName,
      currentValue: value,
      threshold: rule.threshold,
      severity: rule.severity,
      timestamp: new Date().toISOString()
    }
    
    console.error('🚨 性能告警:', alertMessage)
    
    // 发送到外部告警系统
    if (process.env.WEBHOOK_URL) {
      await fetch(process.env.WEBHOOK_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(alertMessage)
      })
    }
  }
}
```

---

## 🔧 优化实施计划

### 短期优化（1-2周）

#### 立即可实施的优化
```typescript
// 1. 代码压缩和Tree Shaking
// next.config.ts
const nextConfig = {
  experimental: {
    optimizeCss: true,
  },
  compiler: {
    removeConsole: process.env.NODE_ENV === 'production'
  },
  images: {
    formats: ['image/webp', 'image/avif'],
    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
  }
}

// 2. 响应压缩
// middleware.ts
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export function middleware(request: NextRequest) {
  const response = NextResponse.next()
  
  // 启用Gzip压缩
  response.headers.set('Content-Encoding', 'gzip')
  
  // 缓存控制
  if (request.nextUrl.pathname.startsWith('/api/')) {
    response.headers.set('Cache-Control', 'no-cache')
  } else {
    response.headers.set('Cache-Control', 'public, max-age=3600')
  }
  
  return response
}

// 3. 数据库查询优化
const optimizedQueries = {
  // 使用select减少数据传输
  getCanteenInfo: (id: string) => prisma.canteen.findUnique({
    where: { id },
    select: {
      id: true,
      canteenName: true,
      hotDishCount: true,
      coldDishCount: true,
      mealType: true,
      createdAt: true
      // 不查询大的历史菜单数据
    }
  }),
  
  // 分页查询
  getMenuHistory: (canteenId: string, page = 1, limit = 4) => prisma.menu.findMany({
    where: { canteenId },
    orderBy: { createdAt: 'desc' },
    skip: (page - 1) * limit,
    take: limit,
    select: {
      id: true,
      weekMenu: true,
      createdAt: true
      // 不查询参数数据，除非需要
    }
  })
}
```

### 中期优化（2-4周）

#### 架构改进
```typescript
// 1. 引入Redis缓存
import Redis from 'ioredis'

const redis = new Redis(process.env.REDIS_URL)

export async function getCachedCanteenInfo(id: string) {
  const cacheKey = `canteen:${id}`
  
  // 尝试从缓存获取
  const cached = await redis.get(cacheKey)
  if (cached) {
    return JSON.parse(cached)
  }
  
  // 从数据库查询
  const canteen = await prisma.canteen.findUnique({
    where: { id },
    select: {
      id: true,
      canteenName: true,
      hotDishCount: true,
      coldDishCount: true,
      mealType: true
    }
  })
  
  // 存入缓存，1小时过期
  if (canteen) {
    await redis.setex(cacheKey, 3600, JSON.stringify(canteen))
  }
  
  return canteen
}

// 2. 数据库连接池优化
const optimizedPrisma = new PrismaClient({
  datasources: {
    db: {
      url: process.env.DATABASE_URL + '?connection_limit=20&pool_timeout=30'
    }
  }
})

// 3. AI API批处理
async function batchGenerateMenus(requests: GenerateMenuRequest[]) {
  const results = await Promise.allSettled(
    requests.map(req => generateSingleMenu(req))
  )
  
  return results.map((result, index) => ({
    request: requests[index],
    success: result.status === 'fulfilled',
    data: result.status === 'fulfilled' ? result.value : null,
    error: result.status === 'rejected' ? result.reason : null
  }))
}
```

### 长期优化（1-3个月）

#### 架构升级
```typescript
// 1. 微服务架构
interface MenuService {
  generateMenu(params: GenerationParams): Promise<WeekMenu>
  validateMenu(menu: WeekMenu): boolean
  saveMenu(canteenId: string, menu: WeekMenu): Promise<string>
}

interface CacheService {
  get<T>(key: string): Promise<T | null>
  set<T>(key: string, value: T, ttl?: number): Promise<void>
  invalidate(pattern: string): Promise<void>
}

interface NotificationService {
  sendAlert(alert: Alert): Promise<void>
  sendNotification(userId: string, message: string): Promise<void>
}

// 2. 事件驱动架构
interface DomainEvent {
  id: string
  type: string
  aggregateId: string
  payload: any
  timestamp: Date
}

class EventBus {
  private handlers: Map<string, Function[]> = new Map()
  
  subscribe(eventType: string, handler: Function) {
    if (!this.handlers.has(eventType)) {
      this.handlers.set(eventType, [])
    }
    this.handlers.get(eventType)!.push(handler)
  }
  
  async publish(event: DomainEvent) {
    const handlers = this.handlers.get(event.type) || []
    await Promise.all(handlers.map(handler => handler(event)))
  }
}

// 事件处理
eventBus.subscribe('MenuGenerated', async (event: DomainEvent) => {
  // 清理缓存
  await cacheService.invalidate(`menu:${event.aggregateId}:*`)
  
  // 发送通知
  await notificationService.sendNotification(
    event.aggregateId, 
    '菜单生成完成'
  )
})

// 3. 监控系统集成
interface MetricsCollector {
  increment(metric: string, tags?: Record<string, string>): void
  histogram(metric: string, value: number, tags?: Record<string, string>): void
  gauge(metric: string, value: number, tags?: Record<string, string>): void
}

// 集成Prometheus/DataDog等监控系统
const metrics = new PrometheusMetrics()

export async function POST(request: NextRequest) {
  const timer = metrics.startTimer('api.request.duration')
  metrics.increment('api.request.count', { method: 'POST', endpoint: '/generate-menu' })
  
  try {
    const result = await processRequest(request)
    metrics.increment('api.request.success')
    return result
  } catch (error) {
    metrics.increment('api.request.error')
    throw error
  } finally {
    timer.end()
  }
}
```

---

## 📈 性能测试

### 负载测试

#### 使用Artillery进行负载测试
```yaml
# artillery-config.yml
config:
  target: 'https://ai-menu.tech'
  phases:
    - duration: 60
      arrivalRate: 5
    - duration: 120
      arrivalRate: 10
    - duration: 60
      arrivalRate: 20
  payload:
    - path: "./test-data.csv"
      fields:
        - canteenName
        - password

scenarios:
  - name: "登录测试"
    weight: 30
    flow:
      - post:
          url: "/api/auth/login"
          json:
            canteenName: "{{ canteenName }}"
            password: "{{ password }}"
          capture:
            - json: "$.success"
              as: "loginSuccess"
      - think: 2

  - name: "菜单生成测试"
    weight: 50
    flow:
      - post:
          url: "/api/auth/login"
          json:
            canteenName: "test_canteen"
            password: "123456"
      - post:
          url: "/api/generate-menu"
          json:
            params:
              mainMeatCount: 3
              halfMeatCount: 3
              vegetarianCount: 2
              staffSituation: "scarce"
              historicalRatio: 30
      - think: 30

  - name: "历史查询测试"
    weight: 20
    flow:
      - get:
          url: "/api/history-menus"
```

#### 性能测试脚本
```bash
#!/bin/bash
# performance-test.sh

echo "开始性能测试..."

# 1. 负载测试
echo "执行负载测试..."
artillery run artillery-config.yml --output load-test-results.json

# 2. 生成报告
artillery report load-test-results.json --output load-test-report.html

# 3. 数据库性能测试
echo "测试数据库性能..."
psql $DATABASE_URL -c "
EXPLAIN ANALYZE 
SELECT * FROM menus 
WHERE canteenId = 'test_id' 
ORDER BY createdAt DESC 
LIMIT 4;
"

# 4. 内存泄露测试
echo "检查内存使用..."
node --inspect --max-old-space-size=512 server.js &
PID=$!
sleep 60
kill $PID

echo "性能测试完成！"
```

### 基准测试

#### API响应时间基准
```typescript
// benchmark.ts
import { performance } from 'perf_hooks'

interface BenchmarkResult {
  operation: string
  samples: number
  avgTime: number
  minTime: number
  maxTime: number
  p95Time: number
}

async function benchmarkAPI() {
  const operations = [
    { name: 'login', url: '/api/auth/login', method: 'POST' },
    { name: 'generateMenu', url: '/api/generate-menu', method: 'POST' },
    { name: 'historyMenus', url: '/api/history-menus', method: 'GET' }
  ]
  
  const results: BenchmarkResult[] = []
  
  for (const op of operations) {
    console.log(`测试 ${op.name}...`)
    
    const times: number[] = []
    const samples = 100
    
    for (let i = 0; i < samples; i++) {
      const start = performance.now()
      
      try {
        await fetch(`https://ai-menu.tech${op.url}`, {
          method: op.method,
          headers: { 'Content-Type': 'application/json' },
          body: op.method === 'POST' ? JSON.stringify(getTestData(op.name)) : undefined
        })
      } catch (error) {
        console.warn(`请求失败: ${error}`)
        continue
      }
      
      const end = performance.now()
      times.push(end - start)
      
      // 避免过于频繁的请求
      await new Promise(resolve => setTimeout(resolve, 100))
    }
    
    times.sort((a, b) => a - b)
    
    results.push({
      operation: op.name,
      samples: times.length,
      avgTime: times.reduce((a, b) => a + b, 0) / times.length,
      minTime: times[0],
      maxTime: times[times.length - 1],
      p95Time: times[Math.floor(times.length * 0.95)]
    })
  }
  
  return results
}

function getTestData(operation: string): any {
  switch (operation) {
    case 'login':
      return { canteenName: 'test_canteen', password: '123456' }
    case 'generateMenu':
      return {
        params: {
          mainMeatCount: 3,
          halfMeatCount: 3,
          vegetarianCount: 2,
          staffSituation: 'scarce',
          historicalRatio: 30,
          equipmentShortage: [],
          spicyLevel: 'mild',
          flavorDiversity: false,
          workRatio: '无要求',
          ingredientDiversity: '无要求'
        }
      }
    default:
      return {}
  }
}

// 运行基准测试
benchmarkAPI().then(results => {
  console.table(results)
  
  // 保存结果
  const fs = require('fs')
  fs.writeFileSync(
    `benchmark-${new Date().toISOString().split('T')[0]}.json`,
    JSON.stringify(results, null, 2)
  )
})
```

---

## 📊 持续监控

### 监控仪表板

#### 核心指标展示
```typescript
// 监控仪表板组件
interface DashboardMetrics {
  responseTime: {
    current: number
    trend: number[]
  }
  throughput: {
    current: number
    trend: number[]
  }
  errorRate: {
    current: number
    trend: number[]
  }
  userCount: {
    active: number
    total: number
  }
}

const MonitoringDashboard = () => {
  const [metrics, setMetrics] = useState<DashboardMetrics>()
  
  useEffect(() => {
    const fetchMetrics = async () => {
      const response = await fetch('/api/metrics')
      const data = await response.json()
      setMetrics(data)
    }
    
    fetchMetrics()
    const interval = setInterval(fetchMetrics, 30000)  // 30秒更新
    
    return () => clearInterval(interval)
  }, [])
  
  return (
    <div className="dashboard">
      <MetricCard
        title="平均响应时间"
        value={`${metrics?.responseTime.current}ms`}
        trend={metrics?.responseTime.trend}
        threshold={2000}
      />
      <MetricCard
        title="请求吞吐量"
        value={`${metrics?.throughput.current}/min`}
        trend={metrics?.throughput.trend}
      />
      <MetricCard
        title="错误率"
        value={`${(metrics?.errorRate.current * 100).toFixed(2)}%`}
        trend={metrics?.errorRate.trend}
        threshold={5}
      />
      <MetricCard
        title="活跃用户"
        value={`${metrics?.userCount.active}/${metrics?.userCount.total}`}
      />
    </div>
  )
}
```

### 自动化优化

#### 自适应性能调优
```typescript
// 自动性能调优系统
class AutoTuner {
  private metrics: PerformanceMetrics[] = []
  private currentConfig: SystemConfig
  
  constructor(initialConfig: SystemConfig) {
    this.currentConfig = initialConfig
  }
  
  async collectMetrics() {
    const current = await this.getCurrentMetrics()
    this.metrics.push(current)
    
    // 保持最近100个数据点
    if (this.metrics.length > 100) {
      this.metrics.shift()
    }
    
    // 分析性能趋势
    this.analyzeTrends()
  }
  
  private analyzeTrends() {
    if (this.metrics.length < 10) return
    
    const recent = this.metrics.slice(-10)
    const avgResponseTime = recent.reduce((sum, m) => sum + m.avgResponseTime, 0) / recent.length
    
    // 如果响应时间过高，自动调整
    if (avgResponseTime > 3000) {
      this.adjustConfiguration({
        cacheSize: Math.min(this.currentConfig.cacheSize * 1.2, 1000),
        connectionPoolSize: Math.min(this.currentConfig.connectionPoolSize + 2, 20),
        timeout: Math.max(this.currentConfig.timeout - 5000, 10000)
      })
    }
    
    // 如果错误率过高，降低负载
    const avgErrorRate = recent.reduce((sum, m) => sum + m.errorRate, 0) / recent.length
    if (avgErrorRate > 0.05) {
      this.adjustConfiguration({
        rateLimitRpm: Math.max(this.currentConfig.rateLimitRpm * 0.8, 60)
      })
    }
  }
  
  private adjustConfiguration(changes: Partial<SystemConfig>) {
    this.currentConfig = { ...this.currentConfig, ...changes }
    
    console.log('自动调优配置:', changes)
    
    // 应用新配置
    this.applyConfiguration(this.currentConfig)
  }
  
  private async applyConfiguration(config: SystemConfig) {
    // 更新环境变量或配置文件
    // 重启相关服务组件
  }
}

interface SystemConfig {
  cacheSize: number
  connectionPoolSize: number
  timeout: number
  rateLimitRpm: number
}
```

---

## 📋 优化检查清单

### 前端优化检查

- [ ] 启用代码分割和懒加载
- [ ] 优化图片和字体加载
- [ ] 实施组件级缓存
- [ ] 使用React.memo和useMemo
- [ ] 减少不必要的重渲染
- [ ] 优化Bundle大小
- [ ] 启用Service Worker
- [ ] 实施预加载策略

### 后端优化检查

- [ ] 数据库查询优化
- [ ] 实施API缓存
- [ ] 优化AI API调用
- [ ] 启用响应压缩
- [ ] 实施连接池
- [ ] 错误处理优化
- [ ] 日志级别调整
- [ ] 清理定时任务

### 数据库优化检查

- [ ] 索引优化完成
- [ ] 查询计划分析
- [ ] 连接池配置
- [ ] 慢查询监控
- [ ] 数据清理策略
- [ ] 备份性能优化
- [ ] 统计信息更新
- [ ] 分区策略评估

### 监控系统检查

- [ ] 关键指标监控
- [ ] 告警规则配置
- [ ] 仪表板部署
- [ ] 日志收集配置
- [ ] 性能基准建立
- [ ] 自动化测试
- [ ] 容量规划
- [ ] 趋势分析

---

