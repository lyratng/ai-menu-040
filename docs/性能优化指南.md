# å›¢é¤èœå•ç”Ÿæˆå·¥å…· - æ€§èƒ½ä¼˜åŒ–æŒ‡å—

## ğŸ“– æ¦‚è¿°

æœ¬æ–‡æ¡£ä¸ºç³»ç»Ÿæ€§èƒ½ä¼˜åŒ–æä¾›å…¨é¢çš„æŒ‡å¯¼ï¼ŒåŒ…æ‹¬å‰ç«¯ä¼˜åŒ–ã€åç«¯ä¼˜åŒ–ã€æ•°æ®åº“ä¼˜åŒ–ã€ç›‘æ§æŒ‡æ ‡ç­‰ã€‚é€šè¿‡ç³»ç»ŸåŒ–çš„ä¼˜åŒ–æªæ–½ï¼Œç¡®ä¿åº”ç”¨åœ¨å„ç§è´Ÿè½½ä¸‹éƒ½èƒ½ä¿æŒè‰¯å¥½çš„ç”¨æˆ·ä½“éªŒã€‚

---

## ğŸ¯ æ€§èƒ½ç›®æ ‡

### æ ¸å¿ƒæŒ‡æ ‡

| æŒ‡æ ‡åç§° | ç›®æ ‡å€¼ | å½“å‰çŠ¶æ€ | ä¼˜åŒ–ä¼˜å…ˆçº§ |
|---------|--------|----------|------------|
| é¦–é¡µåŠ è½½æ—¶é—´ | < 1.5s | ~2.0s | é«˜ |
| èœå•ç”Ÿæˆå“åº” | < 30s | ~45s | é«˜ |
| APIå“åº”æ—¶é—´ | < 500ms | ~800ms | ä¸­ |
| æ•°æ®åº“æŸ¥è¯¢ | < 100ms | ~150ms | ä¸­ |
| Excelå¯¼å‡º | < 2s | ~3s | ä½ |

### ç”¨æˆ·ä½“éªŒç›®æ ‡

- **å¯ç”¨æ€§**ï¼š99.9% æ­£å¸¸è¿è¡Œæ—¶é—´
- **å¹¶å‘æ€§**ï¼šæ”¯æŒ100+å¹¶å‘ç”¨æˆ·
- **å“åº”æ€§**ï¼š3ç§’å†…å®Œæˆæ‰€æœ‰äº¤äº’
- **ç¨³å®šæ€§**ï¼šå†…å­˜ä½¿ç”¨ < 512MB

---

## ğŸš€ å‰ç«¯æ€§èƒ½ä¼˜åŒ–

### ä»£ç åˆ†å‰²å’Œæ‡’åŠ è½½

#### Next.jsåŠ¨æ€å¯¼å…¥
```typescript
// ç»„ä»¶æ‡’åŠ è½½
import dynamic from 'next/dynamic'

// å»¶è¿ŸåŠ è½½é‡çš„ç»„ä»¶
const MenuTable = dynamic(() => import('./MenuTable'), {
  loading: () => <Spin size="large" />,
  ssr: false  // å¦‚æœç»„ä»¶ä¸éœ€è¦æœåŠ¡ç«¯æ¸²æŸ“
})

// é¡µé¢çº§åˆ«çš„ä»£ç åˆ†å‰²
const HistoryPage = dynamic(() => import('../history/page'), {
  loading: () => <div>åŠ è½½ä¸­...</div>
})
```

#### æŒ‰éœ€åŠ è½½åº“
```typescript
// Ant DesignæŒ‰éœ€å¯¼å…¥
import { Button, Form, Table } from 'antd'
// è€Œä¸æ˜¯ import * as antd from 'antd'

// Excelåº“æŒ‰éœ€åŠ è½½
const exportToExcel = async () => {
  const XLSX = await import('xlsx')
  // ä½¿ç”¨XLSXè¿›è¡Œå¯¼å‡º
}

// åŠ¨æ€å¯¼å…¥å·¥å…·åº“
const formatDate = async (date: Date) => {
  const { format } = await import('date-fns')
  return format(date, 'yyyy-MM-dd')
}
```

### èµ„æºä¼˜åŒ–

#### å›¾ç‰‡ä¼˜åŒ–
```typescript
// ä½¿ç”¨Next.js Imageç»„ä»¶
import Image from 'next/image'

// è‡ªåŠ¨ä¼˜åŒ–ã€æ‡’åŠ è½½ã€WebPæ ¼å¼
<Image
  src="/logo.png"
  alt="Logo"
  width={200}
  height={100}
  priority  // é¦–å±å›¾ç‰‡è®¾ç½®ä¼˜å…ˆçº§
  placeholder="blur"  // æ¨¡ç³Šå ä½ç¬¦
/>
```

#### å­—ä½“ä¼˜åŒ–
```typescript
// åœ¨layout.tsxä¸­ä½¿ç”¨Next.jså­—ä½“ä¼˜åŒ–
import { Inter } from 'next/font/google'

const inter = Inter({
  subsets: ['latin'],
  display: 'swap',  // å­—ä½“äº¤æ¢ç­–ç•¥
  preload: true     // é¢„åŠ è½½
})

export default function Layout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="zh-CN" className={inter.className}>
      <body>{children}</body>
    </html>
  )
}
```

### çŠ¶æ€ç®¡ç†ä¼˜åŒ–

#### Reactæ€§èƒ½ä¼˜åŒ–
```typescript
// 1. ä½¿ç”¨useMemoç¼“å­˜è®¡ç®—ç»“æœ
const getDefaultValues = useMemo(() => {
  if (!canteenInfo) return {}
  
  const hotCount = canteenInfo.hotDishCount
  const avgCount = Math.ceil(hotCount / 3)
  
  return {
    mainMeatCount: avgCount,
    halfMeatCount: avgCount,
    vegetarianCount: hotCount - (avgCount * 2),
    // ... å…¶ä»–é»˜è®¤å€¼
  }
}, [canteenInfo])

// 2. ä½¿ç”¨useCallbackä¼˜åŒ–å‡½æ•°å¼•ç”¨
const handleFormSubmit = useCallback(async (values: FormData) => {
  setGenerating(true)
  try {
    await generateMenu(values)
  } finally {
    setGenerating(false)
  }
}, [generateMenu])

// 3. ç»„ä»¶memoä¼˜åŒ–
const MenuTable = memo(({ weekMenu, hotDishCount, coldDishCount }: MenuTableProps) => {
  // ç»„ä»¶å®ç°
}, (prevProps, nextProps) => {
  // è‡ªå®šä¹‰æ¯”è¾ƒé€»è¾‘
  return prevProps.weekMenu === nextProps.weekMenu
})
```

#### æ•°æ®ç¼“å­˜ç­–ç•¥
```typescript
// ä½¿ç”¨SWRè¿›è¡Œæ•°æ®ç¼“å­˜
import useSWR from 'swr'

const fetcher = (url: string) => fetch(url).then(res => res.json())

export function useCanteenInfo() {
  const { data, error, mutate } = useSWR('/api/auth/me', fetcher, {
    revalidateOnFocus: false,
    revalidateOnReconnect: true,
    dedupingInterval: 60000,  // 1åˆ†é’Ÿå†…å»é‡
  })
  
  return {
    canteenInfo: data?.canteen,
    isLoading: !error && !data,
    isError: error,
    refresh: mutate
  }
}

// ä½¿ç”¨ç¼“å­˜
const { canteenInfo, isLoading } = useCanteenInfo()
```

---

## âš¡ åç«¯æ€§èƒ½ä¼˜åŒ–

### APIå“åº”ä¼˜åŒ–

#### å“åº”æ—¶é—´ä¼˜åŒ–
```typescript
// 1. æ¥å£ç¼“å­˜
import { LRUCache } from 'lru-cache'

const cache = new LRUCache<string, any>({
  max: 100,
  ttl: 1000 * 60 * 5  // 5åˆ†é’Ÿç¼“å­˜
})

export async function GET(request: NextRequest) {
  const cacheKey = `canteen:${canteenId}`
  
  // æ£€æŸ¥ç¼“å­˜
  let canteenInfo = cache.get(cacheKey)
  if (!canteenInfo) {
    canteenInfo = await prisma.canteen.findUnique({
      where: { id: canteenId },
      select: {
        id: true,
        canteenName: true,
        hotDishCount: true,
        coldDishCount: true,
        mealType: true,
        // ä¸è¿”å›å¤§å­—æ®µ
        // historicalMenus: true,
      }
    })
    cache.set(cacheKey, canteenInfo)
  }
  
  return NextResponse.json({ canteen: canteenInfo })
}
```

#### æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–
```typescript
// 1. ä½¿ç”¨selectå‡å°‘æ•°æ®ä¼ è¾“
const canteen = await prisma.canteen.findUnique({
  where: { id: canteenId },
  select: {
    id: true,
    canteenName: true,
    hotDishCount: true,
    coldDishCount: true,
    // ä¸æŸ¥è¯¢å¤§çš„JSONå­—æ®µï¼Œé™¤éå¿…è¦
    // historicalMenus: true,
  }
})

// 2. æ‰¹é‡æŸ¥è¯¢ä¼˜åŒ–
const menusWithCanteen = await prisma.menu.findMany({
  where: { canteenId },
  include: {
    canteen: {
      select: {
        canteenName: true
      }
    }
  },
  orderBy: { createdAt: 'desc' },
  take: 4  // é™åˆ¶è¿”å›æ•°é‡
})

// 3. ä½¿ç”¨åŸç”ŸæŸ¥è¯¢ä¼˜åŒ–å¤æ‚åœºæ™¯
const result = await prisma.$queryRaw`
  SELECT m.*, c.canteenName 
  FROM menus m 
  JOIN canteens c ON m.canteenId = c.id 
  WHERE m.canteenId = ${canteenId} 
  ORDER BY m.createdAt DESC 
  LIMIT 4
`
```

### AI APIä¼˜åŒ–

#### è¯·æ±‚ä¼˜åŒ–
```typescript
// 1. è¿æ¥æ± ç®¡ç†
const aiClient = new HTTPClient({
  timeout: 30000,
  keepAlive: true,
  maxSockets: 10
})

// 2. é‡è¯•æœºåˆ¶ä¼˜åŒ–
async function callDeepseekAPIWithRetry(prompt: string, maxRetries = 3): Promise<string> {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const controller = new AbortController()
      const timeoutId = setTimeout(() => controller.abort(), 25000)  // 25ç§’è¶…æ—¶
      
      const response = await fetch('https://api.deepseek.com/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${process.env.DEEPSEEK_API_KEY}`,
        },
        body: JSON.stringify({
          model: 'deepseek-chat',
          messages: [{ role: 'user', content: prompt }],
          temperature: 0.7,
          max_tokens: 3000,  // é€‚å½“é™åˆ¶tokenæ•°é‡
        }),
        signal: controller.signal
      })
      
      clearTimeout(timeoutId)
      
      if (!response.ok) {
        throw new Error(`API Error: ${response.status}`)
      }
      
      const data = await response.json()
      return data.choices[0]?.message?.content
      
    } catch (error) {
      console.warn(`Attempt ${attempt} failed:`, error.message)
      
      if (attempt === maxRetries) {
        throw error
      }
      
      // æŒ‡æ•°é€€é¿
      const delay = Math.pow(2, attempt - 1) * 1000
      await new Promise(resolve => setTimeout(resolve, delay))
    }
  }
}

// 3. Promptä¼˜åŒ–
function optimizePrompt(originalPrompt: string): string {
  // ç§»é™¤ä¸å¿…è¦çš„é‡å¤å†…å®¹
  // å‹ç¼©å†å²èœå•æ•°æ®
  // ç®€åŒ–è¾“å‡ºè¦æ±‚
  return originalPrompt
    .replace(/\n\n+/g, '\n')  // ç§»é™¤å¤šä½™æ¢è¡Œ
    .trim()
}
```

---

## ğŸ—„ æ•°æ®åº“æ€§èƒ½ä¼˜åŒ–

### ç´¢å¼•ä¼˜åŒ–

#### åˆ†ææŸ¥è¯¢æ€§èƒ½
```sql
-- 1. å¯ç”¨æŸ¥è¯¢ç»Ÿè®¡
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;

-- 2. æŸ¥çœ‹æ…¢æŸ¥è¯¢
SELECT 
  query,
  calls,
  total_time,
  mean_time,
  rows
FROM pg_stat_statements 
WHERE mean_time > 100  -- è¶…è¿‡100msçš„æŸ¥è¯¢
ORDER BY mean_time DESC
LIMIT 10;

-- 3. åˆ†ææŸ¥è¯¢è®¡åˆ’
EXPLAIN ANALYZE SELECT * FROM menus 
WHERE canteenId = 'clxxxxx' 
ORDER BY createdAt DESC 
LIMIT 4;
```

#### ä¼˜åŒ–ç´¢å¼•è®¾è®¡
```sql
-- 1. å¤åˆç´¢å¼•ä¼˜åŒ–èœå•æŸ¥è¯¢
CREATE INDEX CONCURRENTLY idx_menus_canteen_created 
ON menus(canteenId, createdAt DESC);

-- 2. éƒ¨åˆ†ç´¢å¼•ä¼˜åŒ–ç‰¹å®šæŸ¥è¯¢
CREATE INDEX CONCURRENTLY idx_menus_recent 
ON menus(canteenId, createdAt) 
WHERE createdAt > NOW() - INTERVAL '30 days';

-- 3. è¡¨è¾¾å¼ç´¢å¼•
CREATE INDEX CONCURRENTLY idx_canteens_name_lower 
ON canteens(LOWER(canteenName));
```

### è¿æ¥æ± ä¼˜åŒ–

#### Prismaè¿æ¥é…ç½®
```typescript
// prisma/schema.prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// è¿æ¥æ± ä¼˜åŒ–
const prisma = new PrismaClient({
  datasources: {
    db: {
      url: process.env.DATABASE_URL + '?connection_limit=10&pool_timeout=20&socket_timeout=30'
    }
  },
  log: process.env.NODE_ENV === 'development' ? ['query', 'info', 'warn'] : ['warn']
})

// è¿æ¥ç”Ÿå‘½å‘¨æœŸç®¡ç†
if (process.env.NODE_ENV === 'production') {
  // ç”Ÿäº§ç¯å¢ƒå®šæœŸæ£€æŸ¥è¿æ¥çŠ¶æ€
  setInterval(async () => {
    try {
      await prisma.$queryRaw`SELECT 1`
    } catch (error) {
      console.error('Database health check failed:', error)
    }
  }, 30000)
}
```

### æ•°æ®æ¸…ç†ç­–ç•¥

#### è‡ªåŠ¨æ¸…ç†è¿‡æœŸæ•°æ®
```typescript
// å®šæœŸæ¸…ç†ä»»åŠ¡
async function cleanupOldData() {
  try {
    // 1. æ¸…ç†è¶…è¿‡90å¤©çš„èœå•è®°å½•
    const oldMenusCount = await prisma.menu.deleteMany({
      where: {
        createdAt: {
          lt: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000)
        }
      }
    })
    
    console.log(`æ¸…ç†äº† ${oldMenusCount.count} æ¡è¿‡æœŸèœå•è®°å½•`)
    
    // 2. ä¿æŒæ¯ä¸ªé£Ÿå ‚æœ€å¤š4æ¡è®°å½•
    const canteens = await prisma.canteen.findMany({
      select: { id: true }
    })
    
    for (const canteen of canteens) {
      const allMenus = await prisma.menu.findMany({
        where: { canteenId: canteen.id },
        orderBy: { createdAt: 'desc' },
        select: { id: true }
      })
      
      if (allMenus.length > 4) {
        await prisma.menu.deleteMany({
          where: {
            id: {
              in: allMenus.slice(4).map(m => m.id)
            }
          }
        })
      }
    }
  } catch (error) {
    console.error('æ•°æ®æ¸…ç†å¤±è´¥:', error)
  }
}

// æ¯å¤©å‡Œæ™¨3ç‚¹æ‰§è¡Œæ¸…ç†
if (process.env.NODE_ENV === 'production') {
  setInterval(cleanupOldData, 24 * 60 * 60 * 1000)
}
```

---

## ğŸ“Š ç›‘æ§å’ŒæŒ‡æ ‡

### æ€§èƒ½ç›‘æ§ä½“ç³»

#### å…³é”®æ€§èƒ½æŒ‡æ ‡(KPI)
```typescript
interface PerformanceMetrics {
  // å“åº”æ—¶é—´æŒ‡æ ‡
  avgResponseTime: number
  p50ResponseTime: number
  p95ResponseTime: number
  p99ResponseTime: number
  
  // ååé‡æŒ‡æ ‡
  requestsPerSecond: number
  requestsPerMinute: number
  
  // é”™è¯¯ç‡æŒ‡æ ‡
  errorRate: number
  timeoutRate: number
  
  // èµ„æºä½¿ç”¨æŒ‡æ ‡
  memoryUsage: number
  cpuUsage: number
  databaseConnections: number
}

// æ€§èƒ½ç›‘æ§ä¸­é—´ä»¶
function performanceMiddleware(req: NextRequest) {
  const startTime = Date.now()
  
  return {
    onFinish: (response: NextResponse) => {
      const duration = Date.now() - startTime
      
      // è®°å½•æ€§èƒ½æŒ‡æ ‡
      console.log(`${req.method} ${req.url} - ${duration}ms - ${response.status}`)
      
      // å‘é€åˆ°ç›‘æ§ç³»ç»Ÿ
      sendMetrics({
        method: req.method,
        url: req.url,
        duration,
        status: response.status,
        timestamp: new Date().toISOString()
      })
    }
  }
}
```

#### è‡ªå®šä¹‰ç›‘æ§ä»ªè¡¨æ¿
```typescript
// å®æ—¶æ€§èƒ½æ•°æ®æ”¶é›†
class PerformanceCollector {
  private metrics: Map<string, number[]> = new Map()
  
  recordMetric(name: string, value: number) {
    if (!this.metrics.has(name)) {
      this.metrics.set(name, [])
    }
    
    const values = this.metrics.get(name)!
    values.push(value)
    
    // ä¿æŒæœ€è¿‘1000ä¸ªæ•°æ®ç‚¹
    if (values.length > 1000) {
      values.shift()
    }
  }
  
  getStats(name: string) {
    const values = this.metrics.get(name) || []
    if (values.length === 0) return null
    
    const sorted = [...values].sort((a, b) => a - b)
    return {
      count: values.length,
      avg: values.reduce((a, b) => a + b, 0) / values.length,
      min: sorted[0],
      max: sorted[sorted.length - 1],
      p50: sorted[Math.floor(sorted.length * 0.5)],
      p95: sorted[Math.floor(sorted.length * 0.95)],
      p99: sorted[Math.floor(sorted.length * 0.99)]
    }
  }
  
  exportMetrics() {
    const report: Record<string, any> = {}
    for (const [name, _] of this.metrics) {
      report[name] = this.getStats(name)
    }
    return report
  }
}

// å…¨å±€æ€§èƒ½æ”¶é›†å™¨
const perfCollector = new PerformanceCollector()

// APIè·¯ç”±ä¸­ä½¿ç”¨
export async function POST(request: NextRequest) {
  const startTime = Date.now()
  
  try {
    // ä¸šåŠ¡é€»è¾‘
    const result = await processRequest(request)
    
    perfCollector.recordMetric('api.success.duration', Date.now() - startTime)
    return result
    
  } catch (error) {
    perfCollector.recordMetric('api.error.duration', Date.now() - startTime)
    perfCollector.recordMetric('api.error.count', 1)
    throw error
  }
}
```

### å‘Šè­¦ç³»ç»Ÿ

#### é˜ˆå€¼ç›‘æ§
```typescript
interface AlertThreshold {
  metricName: string
  threshold: number
  operator: 'gt' | 'lt' | 'eq'
  window: number  // æ—¶é—´çª—å£ï¼ˆç§’ï¼‰
  severity: 'low' | 'medium' | 'high' | 'critical'
}

const alertRules: AlertThreshold[] = [
  {
    metricName: 'api.response.p95',
    threshold: 5000,  // 5ç§’
    operator: 'gt',
    window: 300,      // 5åˆ†é’Ÿ
    severity: 'high'
  },
  {
    metricName: 'api.error.rate',
    threshold: 0.05,  // 5%
    operator: 'gt',
    window: 60,       // 1åˆ†é’Ÿ
    severity: 'critical'
  },
  {
    metricName: 'database.connections',
    threshold: 8,     // 80%çš„è¿æ¥æ± 
    operator: 'gt',
    window: 60,
    severity: 'medium'
  }
]

class AlertManager {
  private alerts: Map<string, Date> = new Map()
  
  checkAlerts(metrics: PerformanceMetrics) {
    for (const rule of alertRules) {
      const value = this.getMetricValue(metrics, rule.metricName)
      const shouldAlert = this.evaluateCondition(value, rule)
      
      if (shouldAlert && !this.isAlertCooldown(rule.metricName)) {
        this.sendAlert(rule, value)
        this.alerts.set(rule.metricName, new Date())
      }
    }
  }
  
  private isAlertCooldown(metricName: string): boolean {
    const lastAlert = this.alerts.get(metricName)
    if (!lastAlert) return false
    
    const cooldownPeriod = 15 * 60 * 1000  // 15åˆ†é’Ÿå†·å´æœŸ
    return Date.now() - lastAlert.getTime() < cooldownPeriod
  }
  
  private async sendAlert(rule: AlertThreshold, value: number) {
    const alertMessage = {
      metric: rule.metricName,
      currentValue: value,
      threshold: rule.threshold,
      severity: rule.severity,
      timestamp: new Date().toISOString()
    }
    
    console.error('ğŸš¨ æ€§èƒ½å‘Šè­¦:', alertMessage)
    
    // å‘é€åˆ°å¤–éƒ¨å‘Šè­¦ç³»ç»Ÿ
    if (process.env.WEBHOOK_URL) {
      await fetch(process.env.WEBHOOK_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(alertMessage)
      })
    }
  }
}
```

---

## ğŸ”§ ä¼˜åŒ–å®æ–½è®¡åˆ’

### çŸ­æœŸä¼˜åŒ–ï¼ˆ1-2å‘¨ï¼‰

#### ç«‹å³å¯å®æ–½çš„ä¼˜åŒ–
```typescript
// 1. ä»£ç å‹ç¼©å’ŒTree Shaking
// next.config.ts
const nextConfig = {
  experimental: {
    optimizeCss: true,
  },
  compiler: {
    removeConsole: process.env.NODE_ENV === 'production'
  },
  images: {
    formats: ['image/webp', 'image/avif'],
    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
  }
}

// 2. å“åº”å‹ç¼©
// middleware.ts
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export function middleware(request: NextRequest) {
  const response = NextResponse.next()
  
  // å¯ç”¨Gzipå‹ç¼©
  response.headers.set('Content-Encoding', 'gzip')
  
  // ç¼“å­˜æ§åˆ¶
  if (request.nextUrl.pathname.startsWith('/api/')) {
    response.headers.set('Cache-Control', 'no-cache')
  } else {
    response.headers.set('Cache-Control', 'public, max-age=3600')
  }
  
  return response
}

// 3. æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–
const optimizedQueries = {
  // ä½¿ç”¨selectå‡å°‘æ•°æ®ä¼ è¾“
  getCanteenInfo: (id: string) => prisma.canteen.findUnique({
    where: { id },
    select: {
      id: true,
      canteenName: true,
      hotDishCount: true,
      coldDishCount: true,
      mealType: true,
      createdAt: true
      // ä¸æŸ¥è¯¢å¤§çš„å†å²èœå•æ•°æ®
    }
  }),
  
  // åˆ†é¡µæŸ¥è¯¢
  getMenuHistory: (canteenId: string, page = 1, limit = 4) => prisma.menu.findMany({
    where: { canteenId },
    orderBy: { createdAt: 'desc' },
    skip: (page - 1) * limit,
    take: limit,
    select: {
      id: true,
      weekMenu: true,
      createdAt: true
      // ä¸æŸ¥è¯¢å‚æ•°æ•°æ®ï¼Œé™¤ééœ€è¦
    }
  })
}
```

### ä¸­æœŸä¼˜åŒ–ï¼ˆ2-4å‘¨ï¼‰

#### æ¶æ„æ”¹è¿›
```typescript
// 1. å¼•å…¥Redisç¼“å­˜
import Redis from 'ioredis'

const redis = new Redis(process.env.REDIS_URL)

export async function getCachedCanteenInfo(id: string) {
  const cacheKey = `canteen:${id}`
  
  // å°è¯•ä»ç¼“å­˜è·å–
  const cached = await redis.get(cacheKey)
  if (cached) {
    return JSON.parse(cached)
  }
  
  // ä»æ•°æ®åº“æŸ¥è¯¢
  const canteen = await prisma.canteen.findUnique({
    where: { id },
    select: {
      id: true,
      canteenName: true,
      hotDishCount: true,
      coldDishCount: true,
      mealType: true
    }
  })
  
  // å­˜å…¥ç¼“å­˜ï¼Œ1å°æ—¶è¿‡æœŸ
  if (canteen) {
    await redis.setex(cacheKey, 3600, JSON.stringify(canteen))
  }
  
  return canteen
}

// 2. æ•°æ®åº“è¿æ¥æ± ä¼˜åŒ–
const optimizedPrisma = new PrismaClient({
  datasources: {
    db: {
      url: process.env.DATABASE_URL + '?connection_limit=20&pool_timeout=30'
    }
  }
})

// 3. AI APIæ‰¹å¤„ç†
async function batchGenerateMenus(requests: GenerateMenuRequest[]) {
  const results = await Promise.allSettled(
    requests.map(req => generateSingleMenu(req))
  )
  
  return results.map((result, index) => ({
    request: requests[index],
    success: result.status === 'fulfilled',
    data: result.status === 'fulfilled' ? result.value : null,
    error: result.status === 'rejected' ? result.reason : null
  }))
}
```

### é•¿æœŸä¼˜åŒ–ï¼ˆ1-3ä¸ªæœˆï¼‰

#### æ¶æ„å‡çº§
```typescript
// 1. å¾®æœåŠ¡æ¶æ„
interface MenuService {
  generateMenu(params: GenerationParams): Promise<WeekMenu>
  validateMenu(menu: WeekMenu): boolean
  saveMenu(canteenId: string, menu: WeekMenu): Promise<string>
}

interface CacheService {
  get<T>(key: string): Promise<T | null>
  set<T>(key: string, value: T, ttl?: number): Promise<void>
  invalidate(pattern: string): Promise<void>
}

interface NotificationService {
  sendAlert(alert: Alert): Promise<void>
  sendNotification(userId: string, message: string): Promise<void>
}

// 2. äº‹ä»¶é©±åŠ¨æ¶æ„
interface DomainEvent {
  id: string
  type: string
  aggregateId: string
  payload: any
  timestamp: Date
}

class EventBus {
  private handlers: Map<string, Function[]> = new Map()
  
  subscribe(eventType: string, handler: Function) {
    if (!this.handlers.has(eventType)) {
      this.handlers.set(eventType, [])
    }
    this.handlers.get(eventType)!.push(handler)
  }
  
  async publish(event: DomainEvent) {
    const handlers = this.handlers.get(event.type) || []
    await Promise.all(handlers.map(handler => handler(event)))
  }
}

// äº‹ä»¶å¤„ç†
eventBus.subscribe('MenuGenerated', async (event: DomainEvent) => {
  // æ¸…ç†ç¼“å­˜
  await cacheService.invalidate(`menu:${event.aggregateId}:*`)
  
  // å‘é€é€šçŸ¥
  await notificationService.sendNotification(
    event.aggregateId, 
    'èœå•ç”Ÿæˆå®Œæˆ'
  )
})

// 3. ç›‘æ§ç³»ç»Ÿé›†æˆ
interface MetricsCollector {
  increment(metric: string, tags?: Record<string, string>): void
  histogram(metric: string, value: number, tags?: Record<string, string>): void
  gauge(metric: string, value: number, tags?: Record<string, string>): void
}

// é›†æˆPrometheus/DataDogç­‰ç›‘æ§ç³»ç»Ÿ
const metrics = new PrometheusMetrics()

export async function POST(request: NextRequest) {
  const timer = metrics.startTimer('api.request.duration')
  metrics.increment('api.request.count', { method: 'POST', endpoint: '/generate-menu' })
  
  try {
    const result = await processRequest(request)
    metrics.increment('api.request.success')
    return result
  } catch (error) {
    metrics.increment('api.request.error')
    throw error
  } finally {
    timer.end()
  }
}
```

---

## ğŸ“ˆ æ€§èƒ½æµ‹è¯•

### è´Ÿè½½æµ‹è¯•

#### ä½¿ç”¨Artilleryè¿›è¡Œè´Ÿè½½æµ‹è¯•
```yaml
# artillery-config.yml
config:
  target: 'https://ai-menu.tech'
  phases:
    - duration: 60
      arrivalRate: 5
    - duration: 120
      arrivalRate: 10
    - duration: 60
      arrivalRate: 20
  payload:
    - path: "./test-data.csv"
      fields:
        - canteenName
        - password

scenarios:
  - name: "ç™»å½•æµ‹è¯•"
    weight: 30
    flow:
      - post:
          url: "/api/auth/login"
          json:
            canteenName: "{{ canteenName }}"
            password: "{{ password }}"
          capture:
            - json: "$.success"
              as: "loginSuccess"
      - think: 2

  - name: "èœå•ç”Ÿæˆæµ‹è¯•"
    weight: 50
    flow:
      - post:
          url: "/api/auth/login"
          json:
            canteenName: "test_canteen"
            password: "123456"
      - post:
          url: "/api/generate-menu"
          json:
            params:
              mainMeatCount: 3
              halfMeatCount: 3
              vegetarianCount: 2
              staffSituation: "scarce"
              historicalRatio: 30
      - think: 30

  - name: "å†å²æŸ¥è¯¢æµ‹è¯•"
    weight: 20
    flow:
      - get:
          url: "/api/history-menus"
```

#### æ€§èƒ½æµ‹è¯•è„šæœ¬
```bash
#!/bin/bash
# performance-test.sh

echo "å¼€å§‹æ€§èƒ½æµ‹è¯•..."

# 1. è´Ÿè½½æµ‹è¯•
echo "æ‰§è¡Œè´Ÿè½½æµ‹è¯•..."
artillery run artillery-config.yml --output load-test-results.json

# 2. ç”ŸæˆæŠ¥å‘Š
artillery report load-test-results.json --output load-test-report.html

# 3. æ•°æ®åº“æ€§èƒ½æµ‹è¯•
echo "æµ‹è¯•æ•°æ®åº“æ€§èƒ½..."
psql $DATABASE_URL -c "
EXPLAIN ANALYZE 
SELECT * FROM menus 
WHERE canteenId = 'test_id' 
ORDER BY createdAt DESC 
LIMIT 4;
"

# 4. å†…å­˜æ³„éœ²æµ‹è¯•
echo "æ£€æŸ¥å†…å­˜ä½¿ç”¨..."
node --inspect --max-old-space-size=512 server.js &
PID=$!
sleep 60
kill $PID

echo "æ€§èƒ½æµ‹è¯•å®Œæˆï¼"
```

### åŸºå‡†æµ‹è¯•

#### APIå“åº”æ—¶é—´åŸºå‡†
```typescript
// benchmark.ts
import { performance } from 'perf_hooks'

interface BenchmarkResult {
  operation: string
  samples: number
  avgTime: number
  minTime: number
  maxTime: number
  p95Time: number
}

async function benchmarkAPI() {
  const operations = [
    { name: 'login', url: '/api/auth/login', method: 'POST' },
    { name: 'generateMenu', url: '/api/generate-menu', method: 'POST' },
    { name: 'historyMenus', url: '/api/history-menus', method: 'GET' }
  ]
  
  const results: BenchmarkResult[] = []
  
  for (const op of operations) {
    console.log(`æµ‹è¯• ${op.name}...`)
    
    const times: number[] = []
    const samples = 100
    
    for (let i = 0; i < samples; i++) {
      const start = performance.now()
      
      try {
        await fetch(`https://ai-menu.tech${op.url}`, {
          method: op.method,
          headers: { 'Content-Type': 'application/json' },
          body: op.method === 'POST' ? JSON.stringify(getTestData(op.name)) : undefined
        })
      } catch (error) {
        console.warn(`è¯·æ±‚å¤±è´¥: ${error}`)
        continue
      }
      
      const end = performance.now()
      times.push(end - start)
      
      // é¿å…è¿‡äºé¢‘ç¹çš„è¯·æ±‚
      await new Promise(resolve => setTimeout(resolve, 100))
    }
    
    times.sort((a, b) => a - b)
    
    results.push({
      operation: op.name,
      samples: times.length,
      avgTime: times.reduce((a, b) => a + b, 0) / times.length,
      minTime: times[0],
      maxTime: times[times.length - 1],
      p95Time: times[Math.floor(times.length * 0.95)]
    })
  }
  
  return results
}

function getTestData(operation: string): any {
  switch (operation) {
    case 'login':
      return { canteenName: 'test_canteen', password: '123456' }
    case 'generateMenu':
      return {
        params: {
          mainMeatCount: 3,
          halfMeatCount: 3,
          vegetarianCount: 2,
          staffSituation: 'scarce',
          historicalRatio: 30,
          equipmentShortage: [],
          spicyLevel: 'mild',
          flavorDiversity: false,
          workRatio: 'æ— è¦æ±‚',
          ingredientDiversity: 'æ— è¦æ±‚'
        }
      }
    default:
      return {}
  }
}

// è¿è¡ŒåŸºå‡†æµ‹è¯•
benchmarkAPI().then(results => {
  console.table(results)
  
  // ä¿å­˜ç»“æœ
  const fs = require('fs')
  fs.writeFileSync(
    `benchmark-${new Date().toISOString().split('T')[0]}.json`,
    JSON.stringify(results, null, 2)
  )
})
```

---

## ğŸ“Š æŒç»­ç›‘æ§

### ç›‘æ§ä»ªè¡¨æ¿

#### æ ¸å¿ƒæŒ‡æ ‡å±•ç¤º
```typescript
// ç›‘æ§ä»ªè¡¨æ¿ç»„ä»¶
interface DashboardMetrics {
  responseTime: {
    current: number
    trend: number[]
  }
  throughput: {
    current: number
    trend: number[]
  }
  errorRate: {
    current: number
    trend: number[]
  }
  userCount: {
    active: number
    total: number
  }
}

const MonitoringDashboard = () => {
  const [metrics, setMetrics] = useState<DashboardMetrics>()
  
  useEffect(() => {
    const fetchMetrics = async () => {
      const response = await fetch('/api/metrics')
      const data = await response.json()
      setMetrics(data)
    }
    
    fetchMetrics()
    const interval = setInterval(fetchMetrics, 30000)  // 30ç§’æ›´æ–°
    
    return () => clearInterval(interval)
  }, [])
  
  return (
    <div className="dashboard">
      <MetricCard
        title="å¹³å‡å“åº”æ—¶é—´"
        value={`${metrics?.responseTime.current}ms`}
        trend={metrics?.responseTime.trend}
        threshold={2000}
      />
      <MetricCard
        title="è¯·æ±‚ååé‡"
        value={`${metrics?.throughput.current}/min`}
        trend={metrics?.throughput.trend}
      />
      <MetricCard
        title="é”™è¯¯ç‡"
        value={`${(metrics?.errorRate.current * 100).toFixed(2)}%`}
        trend={metrics?.errorRate.trend}
        threshold={5}
      />
      <MetricCard
        title="æ´»è·ƒç”¨æˆ·"
        value={`${metrics?.userCount.active}/${metrics?.userCount.total}`}
      />
    </div>
  )
}
```

### è‡ªåŠ¨åŒ–ä¼˜åŒ–

#### è‡ªé€‚åº”æ€§èƒ½è°ƒä¼˜
```typescript
// è‡ªåŠ¨æ€§èƒ½è°ƒä¼˜ç³»ç»Ÿ
class AutoTuner {
  private metrics: PerformanceMetrics[] = []
  private currentConfig: SystemConfig
  
  constructor(initialConfig: SystemConfig) {
    this.currentConfig = initialConfig
  }
  
  async collectMetrics() {
    const current = await this.getCurrentMetrics()
    this.metrics.push(current)
    
    // ä¿æŒæœ€è¿‘100ä¸ªæ•°æ®ç‚¹
    if (this.metrics.length > 100) {
      this.metrics.shift()
    }
    
    // åˆ†ææ€§èƒ½è¶‹åŠ¿
    this.analyzeTrends()
  }
  
  private analyzeTrends() {
    if (this.metrics.length < 10) return
    
    const recent = this.metrics.slice(-10)
    const avgResponseTime = recent.reduce((sum, m) => sum + m.avgResponseTime, 0) / recent.length
    
    // å¦‚æœå“åº”æ—¶é—´è¿‡é«˜ï¼Œè‡ªåŠ¨è°ƒæ•´
    if (avgResponseTime > 3000) {
      this.adjustConfiguration({
        cacheSize: Math.min(this.currentConfig.cacheSize * 1.2, 1000),
        connectionPoolSize: Math.min(this.currentConfig.connectionPoolSize + 2, 20),
        timeout: Math.max(this.currentConfig.timeout - 5000, 10000)
      })
    }
    
    // å¦‚æœé”™è¯¯ç‡è¿‡é«˜ï¼Œé™ä½è´Ÿè½½
    const avgErrorRate = recent.reduce((sum, m) => sum + m.errorRate, 0) / recent.length
    if (avgErrorRate > 0.05) {
      this.adjustConfiguration({
        rateLimitRpm: Math.max(this.currentConfig.rateLimitRpm * 0.8, 60)
      })
    }
  }
  
  private adjustConfiguration(changes: Partial<SystemConfig>) {
    this.currentConfig = { ...this.currentConfig, ...changes }
    
    console.log('è‡ªåŠ¨è°ƒä¼˜é…ç½®:', changes)
    
    // åº”ç”¨æ–°é…ç½®
    this.applyConfiguration(this.currentConfig)
  }
  
  private async applyConfiguration(config: SystemConfig) {
    // æ›´æ–°ç¯å¢ƒå˜é‡æˆ–é…ç½®æ–‡ä»¶
    // é‡å¯ç›¸å…³æœåŠ¡ç»„ä»¶
  }
}

interface SystemConfig {
  cacheSize: number
  connectionPoolSize: number
  timeout: number
  rateLimitRpm: number
}
```

---

## ğŸ“‹ ä¼˜åŒ–æ£€æŸ¥æ¸…å•

### å‰ç«¯ä¼˜åŒ–æ£€æŸ¥

- [ ] å¯ç”¨ä»£ç åˆ†å‰²å’Œæ‡’åŠ è½½
- [ ] ä¼˜åŒ–å›¾ç‰‡å’Œå­—ä½“åŠ è½½
- [ ] å®æ–½ç»„ä»¶çº§ç¼“å­˜
- [ ] ä½¿ç”¨React.memoå’ŒuseMemo
- [ ] å‡å°‘ä¸å¿…è¦çš„é‡æ¸²æŸ“
- [ ] ä¼˜åŒ–Bundleå¤§å°
- [ ] å¯ç”¨Service Worker
- [ ] å®æ–½é¢„åŠ è½½ç­–ç•¥

### åç«¯ä¼˜åŒ–æ£€æŸ¥

- [ ] æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–
- [ ] å®æ–½APIç¼“å­˜
- [ ] ä¼˜åŒ–AI APIè°ƒç”¨
- [ ] å¯ç”¨å“åº”å‹ç¼©
- [ ] å®æ–½è¿æ¥æ± 
- [ ] é”™è¯¯å¤„ç†ä¼˜åŒ–
- [ ] æ—¥å¿—çº§åˆ«è°ƒæ•´
- [ ] æ¸…ç†å®šæ—¶ä»»åŠ¡

### æ•°æ®åº“ä¼˜åŒ–æ£€æŸ¥

- [ ] ç´¢å¼•ä¼˜åŒ–å®Œæˆ
- [ ] æŸ¥è¯¢è®¡åˆ’åˆ†æ
- [ ] è¿æ¥æ± é…ç½®
- [ ] æ…¢æŸ¥è¯¢ç›‘æ§
- [ ] æ•°æ®æ¸…ç†ç­–ç•¥
- [ ] å¤‡ä»½æ€§èƒ½ä¼˜åŒ–
- [ ] ç»Ÿè®¡ä¿¡æ¯æ›´æ–°
- [ ] åˆ†åŒºç­–ç•¥è¯„ä¼°

### ç›‘æ§ç³»ç»Ÿæ£€æŸ¥

- [ ] å…³é”®æŒ‡æ ‡ç›‘æ§
- [ ] å‘Šè­¦è§„åˆ™é…ç½®
- [ ] ä»ªè¡¨æ¿éƒ¨ç½²
- [ ] æ—¥å¿—æ”¶é›†é…ç½®
- [ ] æ€§èƒ½åŸºå‡†å»ºç«‹
- [ ] è‡ªåŠ¨åŒ–æµ‹è¯•
- [ ] å®¹é‡è§„åˆ’
- [ ] è¶‹åŠ¿åˆ†æ

---

